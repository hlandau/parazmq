package socket

type Message interface {
  Parts() [][]byte
  GetAttrString(name string) (string, error)
}

type Socket interface {
  Close() error

  ReadMessage() (msg Message, err error)

  WritePart(body []byte, more bool) error

  Connect(addr string) error
  Disconnect(addr string) error

  Bind(addr string) error
  Unbind(addr string) error

  GetLinger() int
  SetLinger(x int)
  GetIdentity() string
  SetIdentity(x string)
  GetMaxMsgSize() int64
  SetMaxMsgSize(x int64)
  GetMechanism() string
  GetPlainPassword() string
  SetPlainPassword(x string)
  GetPlainServer() bool
  SetPlainServer(x bool)
  SetPlainUsername(x string)
  GetPlainUsername() string
  SetHandshakeInterval(x int)
  SetCurveServerKey(x string)
  SetCurveServer(x bool)
  SetCurveSecretKey(x string)
  SetCurvePublicKey(x string)
  SetConflate(x bool)
  GetRcvBuf() int
  SetRcvBuf(x int)
  GetRcvHWM() int
  SetRcvHWM(x in)
  GetReconnectInterval() int
  SetReconnectInterval(x int)
  GetReconnectIntervalMax() int
  SetReconnectIntervalMax(x int)
  GetRecoveryInterval() int
  SetRecoveryInterval(x int)
  GetSndBuf() int
  SetSndBuf(x int)
  GetSndHWM() int
  SetSndHWM(x int)
  GetTCPKeepalive() int
  SetTCPKeepalive(x int)
  GetTCPKeepaliveCount() int
  SetTCPKeepaliveCount(x int)
  GetTCPKeepaliveIdle() int
  SetTCPKeepaliveIdle(x int)
  GetTCPKeepaliveInterval() int
  SetTCPKeepaliveInterval(x int)
  GetTOS() int
  SetTOS(x int)
  GetType() string // socket type
  GetZAPDomain() string
  SetZAPDomain(x string)
  Subscribe(prefix string)
  Unsubscribe(prefix string)
  SetRouterMandatory(x bool)
  SetRouterHandover(x bool)
  SetReqRelaxed(x bool)
  SetReqCorrelate(x bool)
  SetImmediate(x bool)

}

type socketType byte
const (
  ST_REQ     SocketType = 1+iota
  ST_REP
  ST_DEALER
  ST_ROUTER
  ST_PUB
  ST_SUB
  ST_PUSH
  ST_PULL
  ST_PAIR
  ST_STREAM
)

type socket struct {
  socketType socketType
}

var ErrBadSocketType = errors.New("unsupported socket type")

func parseSocketType(s string) (SocketType, error) {
  switch s {
    case "req":
      return ST_REQ, nil
    case "rep":
      return ST_REP, nil
    case "dealer":
      return ST_DEALER, nil
    case "router":
      return ST_ROUTER, nil
    case "pub":
      return ST_PUB, nil
    case "sub":
      return ST_SUB, nil
    case "push":
      return ST_PUSH, nil
    case "pull":
      return ST_PULL, nil
    case "pair":
      return ST_PAIR, nil
    case "stream":
      return ST_STREAM, nil
    default:
      return nil, ErrBadSocketType
  }
}

var ErrBadNet = errors.New("bad network specification, must be in zmq+SOCKET_TYPE format")

func newSocket(net string) (Socket, error) {
  netp := strings.SplitN(net, "+", 2)
  if len(netp) != 2 || netp[0] != "zmq" {
    return nil, ErrBadNet
  }

  t, err := parseSocketType(netp[1])
  if err != nil {
    return nil, err
  }

  s := &socket {
    socketType: t,
  }
  return s
}

func (self *socket) Connect(addr string) error {

}

func (self *socket) Disconnect(addr string) error {

}

func (self *socket) Bind(addr string) error {

}

func (self *socket) Unbind(addr string) error {

}

func New(net string) (Socket, error) {
  return newSocket(net)
}

type msg struct {
  parts [][]byte
  attrs map[string]string
}

func (self *Message) Parts() [][]byte {
  return self.parts
}

var ErrAttributeNotPresent = errors.New("attribute not present")

func (self *Message) GetAttrString(name string) (string, error) {
  v, ok := self.attrs[name]
  if !ok {
    return "", ErrAttributeNotPresent
  } else {
    return v, nil
  }
}
